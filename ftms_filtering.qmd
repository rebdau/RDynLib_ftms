---
title: "Selecting one representative tree per feature"
format:
  html:
    toc: true
    self-contained: true
author: "Ahlam Mentag, Johannes Rainer"
---

# Introduction

This Quarto document presents the analysis of FTMS flaxseed data for selecting
one representative tree per feature. Preprocessing and feature definition was
performed in [ftms_preprocessing.qmd](ftms_preprocessing.qmd).

# Data import

Loading all required libraries and importing the results from the data
prepocessing.

```{r}
library(dplyr)
library(tidyr)
library(xcms)
library(MsExperiment)
library(Spectra)
library(readxl)
register(SerialParam())
pth <- getwd()
pth
```

First we load the `XcmsExperiment` ftms object

```{r}

load("data/ftms_final2.RData")
class(ftms)
```

Next, we use `featureSpectra()"` to extract all MS2 spectra for each feature
from `ftms` object.

```{r}
ms2 <- featureSpectra(ftms, msLevel = 2)

msLevel(ms2) |>
  table()
```

it returns 1679 MS level 2 spectra. The total number of features for which an
MS2 spectrum was identified is:

```{r}
length(unique(ms2$feature_id))
```

Here we print the initial number of MSLevels.

```{r}
s <- spectra(ftms)
table(msLevel(s))
```

We next define a function to extract the full MSn tree for features.
This function takes an `XcmsExperiment` object as input, extracts the MS2
spectra using `featureSpectra()` function, and then retrieves all MS3 (and
subsequently MS4 spectra) for all these MS2 spectra using the *precScanNum*
spectra variable.

```{r}
ftms_all_levels <- function(ftms) {

  ms2 <- featureSpectra(ftms, msLevel = 2)
  cat("Number of MS2 spectra found:", length(ms2), "\n")

  res <- lapply(unique(ms2$dataOrigin), function(origin) {
    ms2_subset <- filterDataOrigin(ms2, origin)

    ms3_filtered <- filterDataOrigin(filterMsLevel(spectra(ftms), 3), origin)
    ## To support n:m matches
    m <- findMatches(ms2_subset$acquisitionNum, ms3_filtered$precScanNum)
    cat("Number of MS3 matched to MS2:", length(m), "\n")
    ms3_filtered <- ms3_filtered[to(m)]
    ms3_filtered$feature_id <- ms2_subset$feature_id[from(m)]

    ms4_filtered <- filterDataOrigin(filterMsLevel(spectra(ftms), 4), origin)
    m <- findMatches(ms3_filtered$acquisitionNum, ms4_filtered$precScanNum)
    cat("Number of MS4 matched to MS3:", length(m), "\n")
    ms4_filtered <- ms4_filtered[to(m)]
    ms4_filtered$feature_id <- ms3_filtered$feature_id[from(m)]

    # Combine spectra for this origin
    c(ms2_subset, ms3_filtered, ms4_filtered)
  })
    do.call(c, res)
}

ftms_msn_tree <- ftms_all_levels(ftms)

table(msLevel(ftms_msn_tree))
```

Checking the MSn data for one feature - and evaluate if the relationship
between the MSn spectra is correct.

```{r}
ft <- "FT4282"

a <- ftms_msn_tree[ftms_msn_tree$feature_id == ft]
a

#' split by dataOrigin
al <- split(a, a$dataOrigin)

al[[1]]

spectraData(al[[1]], columns = c("msLevel", "acquisitionNum", "precScanNum"))
#' This looks correct. Testing the next

spectraData(al[[2]], columns = c("msLevel", "acquisitionNum", "precScanNum"))
#' This too.

ft <- "FT0649"
a <- ftms_msn_tree[ftms_msn_tree$feature_id == ft]
a

#' split by dataOrigin
al <- split(a, a$dataOrigin)

spectraData(al[[1]], columns = c("msLevel", "acquisitionNum", "precScanNum")) |>
    as.data.frame()
#' Looks correct. Let's see what filterPrecursorScan does

filterPrecursorScan(al[[1]], 3851)
filterPrecursorScan(al[[1]], 3870)
filterPrecursorScan(al[[1]], 3905)
filterPrecursorScan(al[[1]], 3919)
#' Seems to be OK
```

The number of spectra from different MS levels is shown below:

```{r}
table(msLevel(ftms_msn_tree))
```

We next need to group all MSn spectra from one fragment tree together.
The function below creates an *MSntreeID* column grouping related scans into
fragmentation trees based on their parent-child relationships.

```{r}

assign_msntree_id <- function(x) {
  scan_index <- scanIndex(x)
  prec_scan_num <- precScanNum(x)
  ms_level <- msLevel(x)
  data_origin <- dataOrigin(x)

  tree_id <- rep(NA_integer_, length(scan_index))
  global_counter <- 0

  for (origin in unique(data_origin)) {
    idx <- which(data_origin == origin)
    origin_scan_index <- scan_index[idx]
    origin_prec_scan_num <- prec_scan_num[idx]
    origin_ms_level <- ms_level[idx]
    origin_tree_id <- rep(NA_integer_, length(idx))

    
    scan_idx_map <- setNames(seq_along(origin_scan_index), origin_scan_index)

    for (i in seq_along(idx)) {
      level <- origin_ms_level[i]

      if (level == 2) {
        # If MS2 hasn't been assigned yet
        if (is.na(origin_tree_id[i])) {
          global_counter <- global_counter + 1
          origin_tree_id[i] <- global_counter
        }

      } else if (level == 3) {
        parent_scan <- origin_prec_scan_num[i]
        parent_pos <- scan_idx_map[as.character(parent_scan)]
        if (length(parent_pos) == 1 && origin_ms_level[parent_pos] == 2) {
          if (is.na(origin_tree_id[parent_pos])) {
            # Assign tree ID to parent MS2 first
            global_counter <- global_counter + 1
            origin_tree_id[parent_pos] <- global_counter
          }
          origin_tree_id[i] <- origin_tree_id[parent_pos]
        } else if (length(parent_pos) > 1) {
          stop("MS3 spectrum with multiple MS2 parents")
        }

      } else if (level == 4) {
        parent_scan <- origin_prec_scan_num[i]
        parent_pos_ms3 <- scan_idx_map[as.character(parent_scan)]
        if (length(parent_pos_ms3) == 1 && origin_ms_level[parent_pos_ms3] == 3) {
          ms2_scan <- origin_prec_scan_num[parent_pos_ms3]
          parent_pos_ms2 <- scan_idx_map[as.character(ms2_scan)]
          if (length(parent_pos_ms2) == 1 && origin_ms_level[parent_pos_ms2] == 2) {
            # Assign tree ID to MS2 if not yet done
            if (is.na(origin_tree_id[parent_pos_ms2])) {
              global_counter <- global_counter + 1
              origin_tree_id[parent_pos_ms2] <- global_counter
            }
            origin_tree_id[i] <- origin_tree_id[parent_pos_ms2]
          } else if (length(parent_pos_ms2) > 1) {
            stop("MS4 spectrum with multiple MS2 parents")
          }
        } else if (length(parent_pos_ms3) > 1) {
          stop("MS4 spectrum with multiple MS3 parents")
        }
      }
    }

    tree_id[idx] <- origin_tree_id 
  }

  return(tree_id)
}


msntree_ids <- assign_msntree_id(ftms_msn_tree)

ftms_msn_tree$MSntreeID <- msntree_ids
spectraVariables(ftms_msn_tree)

```


```{r}
spectraData(ftms_msn_tree)
```

```{r}
length(unique(msntree_ids))
```

we have 1679 fragmentation tree.




```{r}
# we stored the tree ids and the msLevels to a dataframe
tree_ids <- ftms_msn_tree$MSntreeID
ms_levels <- msLevel(ftms_msn_tree)
df <- data.frame(
  MSntreeID = tree_ids,
  MSLevel = ms_levels
)


#here we take count the last level of each tree
library(dplyr)
max_level_per_tree <- df %>%
  group_by(MSntreeID) %>%
  summarise(max_level = max(MSLevel), .groups = "drop")


table(max_level_per_tree$max_level)

```

The number of trees that go up to MS2 level is : 415
The number of trees that go up to MS3 level is : 338
The number of trees that go up to MS4 level is : 926



Next we select one most representative tree per feature based on the longest one
and if we have many, we select one tree with the highest MS2 precursor intensity

```{r}
library(Spectra)
library(dplyr)

filtered_trees_spectra <- function(db) {

  # Extract metadata from the Spectra object
  sps_data <- spectraData(db)

  # Split by feature_id
  feat_block <- split(sps_data, f = sps_data$feature_id)

  # Selection function applied to each feature block
  selection <- function(feature_block) {
    #Select the most frequent MSnTreeID
    max_number <- max(table(feature_block$MSntreeID))
    FTmax <- names(table(feature_block$MSntreeID))[table(feature_block$MSntreeID) == max_number]
    feat_block_sel1 <- feature_block[feature_block$MSntreeID %in% as.numeric(FTmax), ]
    feat_block_sel1_MS2 <- feat_block_sel1[feat_block_sel1$msLevel == 2, ]

    if (nrow(feat_block_sel1_MS2) == 0) return(NULL)
    #Select the one with the highest MS2 precursor Intensity
    index <- order(feat_block_sel1_MS2$precursorIntensity, decreasing = TRUE)[1]
    selected_FT <- feat_block_sel1_MS2$MSntreeID[index]
    feature_block[feature_block$MSntreeID == selected_FT, ]
  }

  # Apply selection across all feature blocks
  selected_trees_list <- lapply(feat_block, selection)
  selected_trees_df <- do.call(rbind, selected_trees_list)

  # Subset the original spectra object
  selected_sps <- db[db$MSntreeID %in% selected_trees_df$MSntreeID]

  cat("Spectra object filtré avec succès!\n")
  return(selected_sps)
}


ftms_one_tree <- filtered_trees_spectra(ftms_msn_tree)

msLevel(ftms_one_tree) |> table()

```

after selecting one representative tree per feature we have now:
MS2 : 437, MS3 : 523, MS4 : 262


Finally we verify if the number of unique features corresponds to the number of
unique MSntreeID to ensure that we have one tree per feature.
```{r}
length(unique(ftms_one_tree$feature_id))
```


```{r}
length(unique(ftms_one_tree$MSntreeID))
```

we have 437 unique feature and unique MSntreeID, That's mean that we have for
each feature one representative tree.


Now we save the resulting ftms spectra object to a local directory.
```{r}
save(ftms_one_tree, file = "data/ftms_one_tree.RData")
```



```{r}

```
