---
title: "Selecting one representative tree per feature"
format:
  html:
    toc: true
    self-contained: true
author: "Ahlam Mentag, Johannes Rainer"
---

# Introduction

This Quarto document presents the analysis of FTMS flaxseed data for selecting
one representative tree per feature. Preprocessing and feature definition was
performed in [ftms_preprocessing.qmd](ftms_preprocessing.qmd).

# Data import

Loading all required libraries and importing the results from the data
prepocessing.

```{r}
library(dplyr)
library(tidyr)
library(xcms)
library(MsExperiment)
library(Spectra)
library(readxl)
register(SerialParam())
```

First we load the `XcmsExperiment` ftms object

```{r}

load("data/ftms.RData")
class(ftms)
```

Next, we use `featureSpectra()"` to extract all MS2 spectra for each feature
from `ftms` object.

```{r}
ms2 <- featureSpectra(ftms, msLevel = 2)

msLevel(ms2) |>
  table()
```

it returns 1679 MS level 2 spectra. The total number of features for which an
MS2 spectrum was identified is:

```{r}
length(unique(ms2$feature_id))
```

Here we print the initial number of MSLevels.

```{r}
s <- spectra(ftms)
table(msLevel(s))
```

We next define a function to extract the full MSn tree for features.
This function takes an `XcmsExperiment` object as input, extracts the MS2
spectra using `featureSpectra()` function, and then retrieves all MS3 (and
subsequently MS4 spectra) for all these MS2 spectra using the *precScanNum*
spectra variable.

```{r}
ftms_all_levels <- function(ftms) {

  ms2 <- featureSpectra(ftms, msLevel = 2)
  cat("Number of MS2 spectra found:", length(ms2), "\n")

  res <- lapply(unique(ms2$dataOrigin), function(origin) {
    ms2_subset <- filterDataOrigin(ms2, origin)

    ms3_filtered <- filterDataOrigin(filterMsLevel(spectra(ftms), 3), origin)
    ## To support n:m matches
    m <- findMatches(ms2_subset$acquisitionNum, ms3_filtered$precScanNum)
    cat("Number of MS3 matched to MS2:", length(m), "\n")
    ms3_filtered <- ms3_filtered[to(m)]
    ms3_filtered$feature_id <- ms2_subset$feature_id[from(m)]

    ms4_filtered <- filterDataOrigin(filterMsLevel(spectra(ftms), 4), origin)
    m <- findMatches(ms3_filtered$acquisitionNum, ms4_filtered$precScanNum)
    cat("Number of MS4 matched to MS3:", length(m), "\n")
    ms4_filtered <- ms4_filtered[to(m)]
    ms4_filtered$feature_id <- ms3_filtered$feature_id[from(m)]

    # Combine spectra for this origin
    c(ms2_subset, ms3_filtered, ms4_filtered)
  })
    do.call(c, res)
}

ftms_msn_tree <- ftms_all_levels(ftms)

table(msLevel(ftms_msn_tree))
```

Checking the MSn data for one feature - and evaluate if the relationship
between the MSn spectra is correct.

```{r}
ft <- "FT4282"

a <- ftms_msn_tree[ftms_msn_tree$feature_id == ft]
a

#' split by dataOrigin
al <- split(a, a$dataOrigin)

al[[1]]

spectraData(al[[1]], columns = c("msLevel", "acquisitionNum", "precScanNum"))
#' This looks correct. Testing the next

spectraData(al[[2]], columns = c("msLevel", "acquisitionNum", "precScanNum"))
#' This too.

ft <- "FT0649"
a <- ftms_msn_tree[ftms_msn_tree$feature_id == ft]
a

#' split by dataOrigin
al <- split(a, a$dataOrigin)

spectraData(al[[1]], columns = c("msLevel", "acquisitionNum", "precScanNum")) |>
    as.data.frame()
#' Looks correct. Let's see what filterPrecursorScan does

filterPrecursorScan(al[[1]], 3851)
filterPrecursorScan(al[[1]], 3870)
filterPrecursorScan(al[[1]], 3905)
filterPrecursorScan(al[[1]], 3919)
#' Seems to be OK
```

The number of spectra from different MS levels is shown below:

```{r}
table(msLevel(ftms_msn_tree))
```

We next need to group all MSn spectra from one fragment tree together.
The function below creates an *MSntreeID* column grouping related scans into
fragmentation trees based on their parent-child relationships.

```{r}

assign_msntree_id <- function(x) {
  scan_index <- scanIndex(x)
  prec_scan_num <- precScanNum(x)
  ms_level <- msLevel(x)
  data_origin <- dataOrigin(x)

  tree_id <- rep(NA, length(scan_index))
  global_counter <- 0

  for (origin in unique(data_origin)) {
    origin_indices <- which(data_origin == origin)
    origin_scan_index <- scan_index[origin_indices]
    origin_prec_scan_num <- prec_scan_num[origin_indices]
    origin_ms_level <- ms_level[origin_indices]

    origin_tree_id <- rep(NA, length(origin_scan_index))

    for (i in seq_along(origin_scan_index)) {
      if (origin_ms_level[i] == 4) {

        parent_ms3 <- which(origin_scan_index == origin_prec_scan_num[i] & origin_ms_level == 3)
        if (length(parent_ms3) > 0) {
          parent_ms2 <- which(origin_scan_index == origin_prec_scan_num[parent_ms3] & origin_ms_level == 2)
          if (length(parent_ms2) > 1)
            stop("MS4 spectrum with multiple MS2 ids: ", length(parent_ms2),
                 " origin ", origin, " i ", i)
          if (length(parent_ms2) > 0) {
            origin_tree_id[i] <- origin_tree_id[parent_ms2]
          }
        }
      } else if (origin_ms_level[i] == 3) {

        parent_ms2 <- which(origin_scan_index == origin_prec_scan_num[i] & origin_ms_level == 2)
        if (length(parent_ms2) > 1)
          stop("MS3 spectrum with multiple MS2 ids: ", length(parent_ms2),
               " origin ", origin, " i ", i)
        if (length(parent_ms2) > 0) {
          origin_tree_id[i] <- origin_tree_id[parent_ms2]
        }
      } else if (origin_ms_level[i] == 2) {
        global_counter <- global_counter + 1
        origin_tree_id[i] <- global_counter
      }
    }
    tree_id[origin_indices] <- origin_tree_id
  }

  return(tree_id)
}

msntree_ids <- assign_msntree_id(ftms_msn_tree)

ftms_levels$MSntreeID <- msntree_ids
spectraVariables(ftms_levels)

```


```{r}
spectraData(ftms_msn_tree)
```

```{r}
length(unique(msntree_ids))
```

we have 1679 fragmentation tree.




```{r}
# we stored the tree ids and the msLevels to a dataframe
tree_ids <- ftms_levels$MSntreeID
ms_levels <- msLevel(ftms_levels)
df <- data.frame(
  MSntreeID = tree_ids,
  MSLevel = ms_levels
)


#here we take count the last level of each tree
library(dplyr)
max_level_per_tree <- df %>%
  group_by(MSntreeID) %>%
  summarise(max_level = max(MSLevel), .groups = "drop")


table(max_level_per_tree$max_level)

```

The number of trees that go up to MS2 level is : 415
The number of trees that go up to MS3 level is : 338
The number of trees that go up to MS4 level is : 926



Next we select one most representative tree per feature based on the longest one
and if we have many, we select one tree with the highest MS2 precursor intensity

```{r}
library(Spectra)
library(dplyr)

filtered_trees_spectra <- function(db) {

  # Extract metadata from the Spectra object
  sps_data <- spectraData(db)

  # Split by feature_id
  feat_block <- split(sps_data, f = sps_data$feature_id)

  # Selection function applied to each feature block
  selection <- function(feature_block) {
    #Select the most frequent MSnTreeID
    max_number <- max(table(feature_block$MSntreeID))
    FTmax <- names(table(feature_block$MSntreeID))[table(feature_block$MSntreeID) == max_number]
    feat_block_sel1 <- feature_block[feature_block$MSntreeID %in% as.numeric(FTmax), ]
    feat_block_sel1_MS2 <- feat_block_sel1[feat_block_sel1$msLevel == 2, ]

    if (nrow(feat_block_sel1_MS2) == 0) return(NULL)
    #Select the one with the highest MS2 precursor Intensity
    index <- order(feat_block_sel1_MS2$precursorIntensity, decreasing = TRUE)[1]
    selected_FT <- feat_block_sel1_MS2$MSntreeID[index]
    feature_block[feature_block$MSntreeID == selected_FT, ]
  }

  # Apply selection across all feature blocks
  selected_trees_list <- lapply(feat_block, selection)
  selected_trees_df <- do.call(rbind, selected_trees_list)

  # Subset the original spectra object
  selected_sps <- db[db$MSntreeID %in% selected_trees_df$MSntreeID]

  cat("Spectra object filtré avec succès!\n")
  return(selected_sps)
}


ftms_one_tree <- filtered_trees_spectra(ftms_levels)

msLevel(ftms_one_tree) |> table()

```

after selecting one representative tree per feature we have now:
MS2 : 437, MS3 : 523, MS4 : 262


Finally we verify if the number of unique features corresponds to the number of
unique MSntreeID to ensure that we have one tree per feature.
```{r}
length(unique(ftms_one_tree$feature_id))
```


```{r}
length(unique(ftms_one_tree$MSntreeID))
```

we have 437 unique feature and unique MSntreeID, That's mean that we have for
each feature one representative tree.


Now we save the resulting ftms spectra object to a local directory.
```{r}
save(ftms_one_tree, file = "data/ftms_one_tree.RData")
```



```{r}
round_perl <- function(line) {
  # Extraire intensity et mass/position avec regex
  matches <- regmatches(line, regexec(".*intensity = (\\d+\\.?\\d*), mass/position = (\\d+\\.?\\d*).*", line))

  if (length(matches[[1]]) == 3) {
    intensity <- as.numeric(matches[[1]][2])
    mass <- as.numeric(matches[[1]][3])
    # formater mass à 2 décimales, comme sprintf("%.2f", ...)
    mass_formatted <- sprintf("%.2f", mass)
    return(list(intensity = intensity, mass = mass_formatted))
  } else {
    stop("La ligne ne correspond pas au format attendu.")
  }
}

# Exemple d'utilisation :
line <- "some text intensity = 1234.467, mass/position = 45.6789 more text"
round_perl(line)
# Résultat : list(intensity = 1234.567, mass = "45.68")

```
